// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityMemoCommentPayload {
    #[prost(int32, tag = "1")]
    pub memo_id: i32,
    #[prost(int32, tag = "2")]
    pub related_memo_id: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityPayload {
    #[prost(message, optional, tag = "1")]
    pub memo_comment: ::core::option::Option<ActivityMemoCommentPayload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityProvider {
    #[prost(int32, tag = "1")]
    pub id: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "identity_provider::Type", tag = "3")]
    pub r#type: i32,
    #[prost(string, tag = "4")]
    pub identifier_filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub config: ::core::option::Option<IdentityProviderConfig>,
}
/// Nested message and enum types in `IdentityProvider`.
pub mod identity_provider {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Oauth2 = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Oauth2 => "OAUTH2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OAUTH2" => Some(Self::Oauth2),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityProviderConfig {
    #[prost(oneof = "identity_provider_config::Config", tags = "1")]
    pub config: ::core::option::Option<identity_provider_config::Config>,
}
/// Nested message and enum types in `IdentityProviderConfig`.
pub mod identity_provider_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag = "1")]
        Oauth2Config(super::OAuth2Config),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldMapping {
    #[prost(string, tag = "1")]
    pub identifier: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OAuth2Config {
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_secret: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub auth_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_url: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub user_info_url: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub field_mapping: ::core::option::Option<FieldMapping>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InboxMessage {
    #[prost(enumeration = "inbox_message::Type", tag = "1")]
    pub r#type: i32,
    #[prost(int32, optional, tag = "2")]
    pub activity_id: ::core::option::Option<i32>,
}
/// Nested message and enum types in `InboxMessage`.
pub mod inbox_message {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        MemoComment = 1,
        VersionUpdate = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::MemoComment => "MEMO_COMMENT",
                Self::VersionUpdate => "VERSION_UPDATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MEMO_COMMENT" => Some(Self::MemoComment),
                "VERSION_UPDATE" => Some(Self::VersionUpdate),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct MemoPayload {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<memo_payload::Property>,
    #[prost(message, optional, tag = "2")]
    pub location: ::core::option::Option<memo_payload::Location>,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `MemoPayload`.
pub mod memo_payload {
    /// The calculated properties from the memo content.
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
    pub struct Property {
        #[prost(bool, tag = "1")]
        pub has_link: bool,
        #[prost(bool, tag = "2")]
        pub has_task_list: bool,
        #[prost(bool, tag = "3")]
        pub has_code: bool,
        #[prost(bool, tag = "4")]
        pub has_incomplete_tasks: bool,
        /// The references of the memo. Should be a list of uuid.
        #[prost(string, repeated, tag = "5")]
        pub references: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
    pub struct Location {
        #[prost(string, tag = "1")]
        pub placeholder: ::prost::alloc::string::String,
        #[prost(double, tag = "2")]
        pub latitude: f64,
        #[prost(double, tag = "3")]
        pub longitude: f64,
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceSetting {
    #[prost(enumeration = "WorkspaceSettingKey", tag = "1")]
    pub key: i32,
    #[prost(oneof = "workspace_setting::Value", tags = "2, 3, 4, 5")]
    pub value: ::core::option::Option<workspace_setting::Value>,
}
/// Nested message and enum types in `WorkspaceSetting`.
pub mod workspace_setting {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "2")]
        BasicSetting(super::WorkspaceBasicSetting),
        #[prost(message, tag = "3")]
        GeneralSetting(super::WorkspaceGeneralSetting),
        #[prost(message, tag = "4")]
        StorageSetting(super::WorkspaceStorageSetting),
        #[prost(message, tag = "5")]
        MemoRelatedSetting(super::WorkspaceMemoRelatedSetting),
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceBasicSetting {
    /// The secret key for workspace. Mainly used for session management.
    #[prost(string, tag = "1")]
    pub secret_key: ::prost::alloc::string::String,
    /// The current schema version of database.
    #[prost(string, tag = "2")]
    pub schema_version: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceGeneralSetting {
    /// disallow_user_registration disallows user registration.
    #[prost(bool, tag = "1")]
    pub disallow_user_registration: bool,
    /// disallow_password_auth disallows password authentication.
    #[prost(bool, tag = "2")]
    pub disallow_password_auth: bool,
    /// additional_script is the additional script.
    #[prost(string, tag = "3")]
    pub additional_script: ::prost::alloc::string::String,
    /// additional_style is the additional style.
    #[prost(string, tag = "4")]
    pub additional_style: ::prost::alloc::string::String,
    /// custom_profile is the custom profile.
    #[prost(message, optional, tag = "5")]
    pub custom_profile: ::core::option::Option<WorkspaceCustomProfile>,
    /// week_start_day_offset is the week start day offset from Sunday.
    /// 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday
    /// Default is Sunday.
    #[prost(int32, tag = "6")]
    pub week_start_day_offset: i32,
    /// disallow_change_username disallows changing username.
    #[prost(bool, tag = "7")]
    pub disallow_change_username: bool,
    /// disallow_change_nickname disallows changing nickname.
    #[prost(bool, tag = "8")]
    pub disallow_change_nickname: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceCustomProfile {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub logo_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub appearance: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceStorageSetting {
    /// storage_type is the storage type.
    #[prost(enumeration = "workspace_storage_setting::StorageType", tag = "1")]
    pub storage_type: i32,
    /// The template of file path.
    /// e.g. assets/{timestamp}_{filename}
    #[prost(string, tag = "2")]
    pub filepath_template: ::prost::alloc::string::String,
    /// The max upload size in megabytes.
    #[prost(int64, tag = "3")]
    pub upload_size_limit_mb: i64,
    /// The S3 config.
    #[prost(message, optional, tag = "4")]
    pub s3_config: ::core::option::Option<StorageS3Config>,
}
/// Nested message and enum types in `WorkspaceStorageSetting`.
pub mod workspace_storage_setting {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StorageType {
        Unspecified = 0,
        /// STORAGE_TYPE_DATABASE is the database storage type.
        Database = 1,
        /// STORAGE_TYPE_LOCAL is the local storage type.
        Local = 2,
        /// STORAGE_TYPE_S3 is the S3 storage type.
        S3 = 3,
    }
    impl StorageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STORAGE_TYPE_UNSPECIFIED",
                Self::Database => "DATABASE",
                Self::Local => "LOCAL",
                Self::S3 => "S3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATABASE" => Some(Self::Database),
                "LOCAL" => Some(Self::Local),
                "S3" => Some(Self::S3),
                _ => None,
            }
        }
    }
}
/// Reference: <https://developers.cloudflare.com/r2/examples/aws/aws-sdk-go/>
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StorageS3Config {
    #[prost(string, tag = "1")]
    pub access_key_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub access_key_secret: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub bucket: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub use_path_style: bool,
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WorkspaceMemoRelatedSetting {
    /// disallow_public_visibility disallows set memo as public visibility.
    #[prost(bool, tag = "1")]
    pub disallow_public_visibility: bool,
    /// display_with_update_time orders and displays memo with update time.
    #[prost(bool, tag = "2")]
    pub display_with_update_time: bool,
    /// content_length_limit is the limit of content length. Unit is byte.
    #[prost(int32, tag = "3")]
    pub content_length_limit: i32,
    /// enable_double_click_edit enables editing on double click.
    #[prost(bool, tag = "5")]
    pub enable_double_click_edit: bool,
    /// enable_link_preview enables links preview.
    #[prost(bool, tag = "6")]
    pub enable_link_preview: bool,
    /// enable_comment enables comment.
    #[prost(bool, tag = "7")]
    pub enable_comment: bool,
    /// enable_location enables setting location for memo.
    #[prost(bool, tag = "8")]
    pub enable_location: bool,
    /// reactions is the list of reactions.
    #[prost(string, repeated, tag = "10")]
    pub reactions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// disable markdown shortcuts
    #[prost(bool, tag = "11")]
    pub disable_markdown_shortcuts: bool,
    /// enable_blur_nsfw_content enables blurring of content marked as not safe for work (NSFW).
    #[prost(bool, tag = "12")]
    pub enable_blur_nsfw_content: bool,
    /// nsfw_tags is the list of tags that mark content as NSFW for blurring.
    #[prost(string, repeated, tag = "13")]
    pub nsfw_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkspaceSettingKey {
    Unspecified = 0,
    /// BASIC is the key for basic settings.
    Basic = 1,
    /// GENERAL is the key for general settings.
    General = 2,
    /// STORAGE is the key for storage settings.
    Storage = 3,
    /// MEMO_RELATED is the key for memo related settings.
    MemoRelated = 4,
}
impl WorkspaceSettingKey {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKSPACE_SETTING_KEY_UNSPECIFIED",
            Self::Basic => "BASIC",
            Self::General => "GENERAL",
            Self::Storage => "STORAGE",
            Self::MemoRelated => "MEMO_RELATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKSPACE_SETTING_KEY_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "GENERAL" => Some(Self::General),
            "STORAGE" => Some(Self::Storage),
            "MEMO_RELATED" => Some(Self::MemoRelated),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ResourcePayload {
    #[prost(oneof = "resource_payload::Payload", tags = "1")]
    pub payload: ::core::option::Option<resource_payload::Payload>,
}
/// Nested message and enum types in `ResourcePayload`.
pub mod resource_payload {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
    pub struct S3Object {
        #[prost(message, optional, tag = "1")]
        pub s3_config: ::core::option::Option<super::StorageS3Config>,
        /// key is the S3 object key.
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
        /// last_presigned_time is the last time the object was presigned.
        /// This is used to determine if the presigned URL is still valid.
        #[prost(message, optional, tag = "3")]
        #[serde(with = "crate::model::time_serde")]
        pub last_presigned_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        S3Object(S3Object),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceStorageType {
    Unspecified = 0,
    /// Resource is stored locally. AKA, local file system.
    Local = 1,
    /// Resource is stored in S3.
    S3 = 2,
    /// Resource is stored in an external storage. The reference is a URL.
    External = 3,
}
impl ResourceStorageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_STORAGE_TYPE_UNSPECIFIED",
            Self::Local => "LOCAL",
            Self::S3 => "S3",
            Self::External => "EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_STORAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "LOCAL" => Some(Self::Local),
            "S3" => Some(Self::S3),
            "EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserSetting {
    #[prost(int32, tag = "1")]
    pub user_id: i32,
    #[prost(enumeration = "UserSettingKey", tag = "2")]
    pub key: i32,
    #[prost(oneof = "user_setting::Value", tags = "3, 4, 5, 6, 7")]
    pub value: ::core::option::Option<user_setting::Value>,
}
/// Nested message and enum types in `UserSetting`.
pub mod user_setting {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "3")]
        AccessTokens(super::AccessTokensUserSetting),
        #[prost(string, tag = "4")]
        Locale(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        Appearance(::prost::alloc::string::String),
        #[prost(string, tag = "6")]
        MemoVisibility(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        Shortcuts(super::ShortcutsUserSetting),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessTokensUserSetting {
    #[prost(message, repeated, tag = "1")]
    pub access_tokens: ::prost::alloc::vec::Vec<access_tokens_user_setting::AccessToken>,
}
/// Nested message and enum types in `AccessTokensUserSetting`.
pub mod access_tokens_user_setting {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessToken {
        /// The access token is a JWT token.
        /// Including expiration time, issuer, etc.
        #[prost(string, tag = "1")]
        pub access_token: ::prost::alloc::string::String,
        /// A description for the access token.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShortcutsUserSetting {
    #[prost(message, repeated, tag = "1")]
    pub shortcuts: ::prost::alloc::vec::Vec<shortcuts_user_setting::Shortcut>,
}
/// Nested message and enum types in `ShortcutsUserSetting`.
pub mod shortcuts_user_setting {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shortcut {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub filter: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserSettingKey {
    Unspecified = 0,
    /// Access tokens for the user.
    AccessTokens = 1,
    /// The locale of the user.
    Locale = 2,
    /// The appearance of the user.
    Appearance = 3,
    /// The visibility of the memo.
    MemoVisibility = 4,
    /// The shortcuts of the user.
    Shortcuts = 5,
}
impl UserSettingKey {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_SETTING_KEY_UNSPECIFIED",
            Self::AccessTokens => "ACCESS_TOKENS",
            Self::Locale => "LOCALE",
            Self::Appearance => "APPEARANCE",
            Self::MemoVisibility => "MEMO_VISIBILITY",
            Self::Shortcuts => "SHORTCUTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_SETTING_KEY_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCESS_TOKENS" => Some(Self::AccessTokens),
            "LOCALE" => Some(Self::Locale),
            "APPEARANCE" => Some(Self::Appearance),
            "MEMO_VISIBILITY" => Some(Self::MemoVisibility),
            "SHORTCUTS" => Some(Self::Shortcuts),
            _ => None,
        }
    }
}
